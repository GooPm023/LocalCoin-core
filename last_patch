diff --git a/genesis.json b/genesis.json
index edee7b20..dfe4be7b 100644
--- a/genesis.json
+++ b/genesis.json
@@ -260,7 +260,7 @@
             "scale": 10000
         },
         "block_interval": 2,
-        "maintenance_interval": 86400,
+        "maintenance_interval": 60,
         "maintenance_skip_slots": 3,
         "committee_proposal_review_period": 1209600,
         "maximum_transaction_size": 2048,
@@ -294,13 +294,15 @@
 			"name": "ratamahatta",
 			"owner_key": "LLC5As5Lds81xuPevHswM1qDjYYyLBJgDcWXHLa16mZFtznHnYTL5",
 			"active_key": "LLC5As5Lds81xuPevHswM1qDjYYyLBJgDcWXHLa16mZFtznHnYTL5",
-			"is_lifetime_member": true
+			"is_lifetime_member": true,
+         "is_system_account": true
 		  },
 		  {
 			"name": "adamgottie",
 			"owner_key": "LLC7DotXzjTBA4XDB4s7LFVdX8ZLMm8XxpTLi8CT1fRDCgKyRt4ER",
 			"active_key": "LLC7DotXzjTBA4XDB4s7LFVdX8ZLMm8XxpTLi8CT1fRDCgKyRt4ER",
-			"is_lifetime_member": true
+			"is_lifetime_member": true,
+         "is_system_account": true
 		  },
 		  {
 			"name": "winstonsmith",
@@ -19819,11 +19821,10 @@
 		  { "owner_name": "germut"      }
 		],
     "initial_worker_candidates": [],
-    "initial_chain_id": "aa34045518f1469a28fa4578240d5f039afa9959c0b95ce3b39674efa691fb21",
     "immutable_parameters": {
         "min_committee_member_count": 21,
         "min_witness_count": 9,
         "num_special_accounts": 0,
         "num_special_assets": 0
     }
-}
+}
\ No newline at end of file
diff --git a/libraries/chain/db_activenode_schedule.cpp b/libraries/chain/db_activenode_schedule.cpp
index 0ce0c6bf..df9fa75b 100644
--- a/libraries/chain/db_activenode_schedule.cpp
+++ b/libraries/chain/db_activenode_schedule.cpp
@@ -45,7 +45,7 @@ fc::optional<activenode_id_type> database::get_scheduled_activenode(uint32_t blo
       return fc::optional<activenode_id_type>();
 
    FC_ASSERT(block_num == head_block_num() || block_num == head_block_num() - 1);   
-   return aso.current_shuffled_activenodes[block_num - dpo.last_scheduling_block_num];
+   return aso.current_shuffled_activenodes[block_num - dpo.current_scheduling_block_num];
 }
 
 void database::update_activenode_schedule()
@@ -83,7 +83,7 @@ void database::update_activenode_schedule()
       });
       modify( dpo, [&]( dynamic_global_property_object& _dpo )
       {
-         _dpo.last_scheduling_block_num = head_block_num();
+         _dpo.current_scheduling_block_num = head_block_num();
       } );
    }
 }
diff --git a/libraries/chain/db_maint.cpp b/libraries/chain/db_maint.cpp
index d980ff9b..82200b97 100644
--- a/libraries/chain/db_maint.cpp
+++ b/libraries/chain/db_maint.cpp
@@ -202,23 +202,123 @@ void database::pay_workers( share_type& budget )
    }
 }
 
+void database::burn_account_coins(account_id_type account, asset amount) {
+
+   const asset_dynamic_data_object& core =
+      asset_id_type(0)(*this).dynamic_asset_data_id(*this);
+
+   wlog("before reduce supply ${supply} and account ${acc} by ${amount}",("supply", core.current_supply)("acc", account)("amount", amount.amount) );
+
+
+   modify(core, [&]( asset_dynamic_data_object& _core )
+   {
+      _core.current_supply = _core.current_supply - amount.amount;
+   });
+
+   adjust_balance( account, -amount );
+   wlog("reduced current supply ${supply} and account ${acc} by ${amount}",("supply", core.current_supply)("acc", account)("amount", amount.amount) );
+}
+
 void database::update_current_activenodes()
 { try {
    const global_property_object& gpo = get_global_properties();
+   const dynamic_global_property_object& dpo = get_dynamic_global_properties();
 
    const auto& anodes = get_index_type<activenode_index>().indices();
 
+   uint32_t blocks_since_maintenance = head_block_num() - gpo.previous_maintenance_block_num;
+   dlog("blocks_since_maintenance ${blocks} (head block ${head_block}; prev_maint_block ${prev_maint}", ("blocks", blocks_since_maintenance)("head_block", head_block_num())("prev_maint",gpo.previous_maintenance_block_num));
+   uint32_t min_blocks_per_node = 0;
+   if (gpo.current_activenodes.size()) 
+      min_blocks_per_node = blocks_since_maintenance / gpo.current_activenodes.size() / 2;
+
+   if (gpo.current_activenodes.size() > blocks_since_maintenance /2) {
+      wlog("Not every node will get reward - there is more than blocks_since_maintenance/2 activenodes (${nodes}/${blocks}", ("nodes", gpo.current_activenodes.size())("blocks", blocks_since_maintenance /2));
+   }
+
+   std::vector<activenode_id_type> new_activenodes;
+
+   for( const activenode_object& anode : anodes ) {
+      // ilog("list nodes ${node}", ("node", anode.id));
+
+      // node is still having penalty
+      if (anode.penalty_left > 0) {
+         modify(anode, [&]( activenode_object& anode_obj ){
+            anode_obj.penalty_left--;
+         });
+         
+         if (anode.penalty_left != 0) {
+            dlog("node ${node} penalty ${penalty}", ("node", anode.id)("penalty", anode.penalty_left));
+            continue;
+         }
+         share_type account_balance = get_balance(anode.activenode_account, asset_id_type()).amount.value;
+         chain::activenode_create_operation create_op;
+
+         asset create_anode_fee = current_fee_schedule().calculate_fee( create_op );
+         if (account_balance < LLC_ACTIVENODE_MINIMAL_BALANCE_AFTER_SEND + create_anode_fee.amount) {
+            // если balance < min_balance + create_anode.fee, то не возвращаем к жизни, т.к. сразу удалим
+            continue;
+         }
+         wlog("fine node ${node} coins ${amount} for returning to active", ("node", anode.id)("amount", create_anode_fee));
+         burn_account_coins(anode.activenode_account, create_anode_fee);
+         new_activenodes.push_back(anode.id);
+      }
+      else {
+         elog("node ${node} activity ${sent}/${min_blocks}", ("node", anode.id)("sent", anode.activities_sent)("min_blocks", min_blocks_per_node));
+         uint32_t activities_num = anode.activities_sent;
+         if (anode.activities_sent >= min_blocks_per_node) {
+            new_activenodes.push_back(anode.id);
+            modify(anode, [&]( activenode_object& anode_obj ){
+               anode_obj.activities_sent = 0;
+            });
+            continue;
+         }
+
+         // if node didn't exist and it is here - we should add it
+         if (anode.is_new) {
+            new_activenodes.push_back(anode.id);
+            modify(anode, [&]( activenode_object& anode_obj ){
+               anode_obj.is_new = false;
+            });
+            continue;
+         }
+
+         modify(anode, [&]( activenode_object& anode_obj ){
+            anode_obj.activities_sent = 0;
+         });
+         
+         if (anode.max_penalty == LLC_ACTIVENODE_MAX_MISS_PENALTY) {
+            elog("removing inactive node ${anode}", ("anode", anode.id));
+            remove(anode);
+            continue;
+         }
+         modify(anode, [&]( activenode_object& anode_obj ){
+            if (!anode_obj.max_penalty) {
+               anode_obj.max_penalty = 1;
+            }
+            else 
+               anode_obj.max_penalty *= 2;
+            anode_obj.penalty_left = anode_obj.max_penalty;
+         });
+         dlog("update node ${node} penalty to ${penalty}", ("node", anode.id)("penalty", anode.penalty_left));
+      }
+   }
+
    modify(gpo, [&]( global_property_object& gp ){
          
       gp.current_activenodes.clear();
-      gp.current_activenodes.reserve(anodes.size());
+      gp.current_activenodes.reserve(new_activenodes.size());
 
-      std::transform(anodes.begin(), anodes.end(),
+      std::transform(new_activenodes.begin(), new_activenodes.end(),
          std::inserter(gp.current_activenodes, gp.current_activenodes.end()),
-            [](const activenode_object& anode) {
-               return anode.id;
+            [](const activenode_id_type& anode_id) {
+               return anode_id;
          });
    });
+
+   for (auto& node: gpo.current_activenodes) {
+      ilog("update_current_activenodes node: ${node}", ("node", node));
+   }
 } FC_CAPTURE_AND_RETHROW() }
 
 void database::update_active_witnesses()
@@ -838,6 +938,9 @@ void database::perform_chain_maintenance(const signed_block& next_block, const g
 {
    dlog("chain_maintenance");
    const auto& gpo = get_global_properties();
+   const auto& dpo = get_dynamic_global_properties();
+   dlog("dynamic global properties ${dyn_glob_props}", ("dyn_glob_props", dpo));
+   dlog("global properties ${glob_props}", ("glob_props", gpo));
 
    distribute_fba_balances(*this);
    create_buyback_orders(*this);
@@ -935,7 +1038,14 @@ void database::perform_chain_maintenance(const signed_block& next_block, const g
 
    update_top_n_authorities(*this);
    update_active_witnesses();
+   //here we need to calc how many blocks each activenode has missed and throw them away if < 50%
+   // but if there more than blocks_in_interval/2 activenodes, then not every node will be granted with at least 2 blocks
    update_current_activenodes();
+   modify( gpo, [&]( global_property_object& _gpo )
+   {
+      ilog("modify gpo head_block_num ${num}", ("num", head_block_num()));
+      _gpo.previous_maintenance_block_num = head_block_num();
+   } );
    update_active_committee_members();
    update_worker_votes();
 
diff --git a/libraries/chain/db_update.cpp b/libraries/chain/db_update.cpp
index ca838818..37f38e29 100644
--- a/libraries/chain/db_update.cpp
+++ b/libraries/chain/db_update.cpp
@@ -178,16 +178,20 @@ void database::reward_activenode(const signed_block& new_block) {
       // was deleted
       return;
    }
-   auto& activenode_object = (*scheduled_activenode)(*this);
+   auto& activenode = (*scheduled_activenode)(*this);
    signed_block prev_block = *fetch_block_by_number(new_block.block_num() - 1);
    fc::time_point_sec prev_block_time = prev_block.timestamp;
-   if (activenode_object.last_activity == prev_block_time) {
+   if (activenode.last_activity == prev_block_time) {
+      modify( activenode, [&]( activenode_object& _ano )
+      {
+         _ano.activities_sent++;
+      } );
 
       chain::activenode_send_activity_operation send_activity_operation;
 
       share_type fee = current_fee_schedule().calculate_fee( send_activity_operation ).amount;
       share_type to_deposit = fee.value * 0.2 + gpo.parameters.activenode_pay_per_block;
-      deposit_activenode_pay( activenode_object, to_deposit );
+      deposit_activenode_pay( activenode, to_deposit );
    }
 }
 
diff --git a/libraries/chain/include/graphene/chain/activenode_object.hpp b/libraries/chain/include/graphene/chain/activenode_object.hpp
index 55395e68..bdbfcc8c 100644
--- a/libraries/chain/include/graphene/chain/activenode_object.hpp
+++ b/libraries/chain/include/graphene/chain/activenode_object.hpp
@@ -40,6 +40,12 @@ namespace graphene { namespace chain {
 
          account_id_type  activenode_account;
          fc::time_point_sec last_activity;
+         
+         uint32_t activities_sent = 0;
+         uint8_t penalty_left = 0;
+         uint8_t max_penalty = 0;
+
+         bool is_new = true;
 
          fc::ip::endpoint endpoint;
          optional< vesting_balance_id_type > pay_vb;
@@ -68,4 +74,8 @@ FC_REFLECT_DERIVED( graphene::chain::activenode_object, (graphene::db::object),
                     (endpoint)
                     (pay_vb)
                     (is_enabled)
+                    (activities_sent)
+                    (penalty_left)
+                    (max_penalty)
+                    (is_new)
                   )
\ No newline at end of file
diff --git a/libraries/chain/include/graphene/chain/config.hpp b/libraries/chain/include/graphene/chain/config.hpp
index 2011ee1c..a7397daa 100644
--- a/libraries/chain/include/graphene/chain/config.hpp
+++ b/libraries/chain/include/graphene/chain/config.hpp
@@ -180,3 +180,4 @@
 
 #define LLC_ACTIVENODE_MINIMAL_BALANCE_AFTER_SEND (500 * GRAPHENE_BLOCKCHAIN_PRECISION)
 #define LLC_ACTIVENODE_MINIMAL_BALANCE_CREATE (511 * GRAPHENE_BLOCKCHAIN_PRECISION)
+#define LLC_ACTIVENODE_MAX_MISS_PENALTY (8)
diff --git a/libraries/chain/include/graphene/chain/database.hpp b/libraries/chain/include/graphene/chain/database.hpp
index 66c7b4bc..48045895 100644
--- a/libraries/chain/include/graphene/chain/database.hpp
+++ b/libraries/chain/include/graphene/chain/database.hpp
@@ -492,6 +492,9 @@ namespace graphene { namespace chain {
 
          template<class... Types>
          void perform_account_maintenance(std::tuple<Types...> helpers);
+
+         void burn_account_coins(account_id_type account, asset amount);
+
          ///@}
          ///@}
 
diff --git a/libraries/chain/include/graphene/chain/global_property_object.hpp b/libraries/chain/include/graphene/chain/global_property_object.hpp
index d677372e..e51e2b01 100644
--- a/libraries/chain/include/graphene/chain/global_property_object.hpp
+++ b/libraries/chain/include/graphene/chain/global_property_object.hpp
@@ -52,6 +52,8 @@ namespace graphene { namespace chain {
          vector<committee_member_id_type>   active_committee_members; // updated once per maintenance interval
          flat_set<witness_id_type>          active_witnesses; // updated once per maintenance interval
          flat_set<activenode_id_type>          current_activenodes; // updated once per maintenance interval
+         uint32_t previous_maintenance_block_num = 0;
+
 
          // n.b. witness scheduling is done by witness_schedule object
    };
@@ -110,7 +112,7 @@ namespace graphene { namespace chain {
 
          uint32_t last_irreversible_block_num = 0;
 
-         uint32_t last_scheduling_block_num = 0;
+         uint32_t current_scheduling_block_num = 0;
 
          enum dynamic_flag_bits
          {
@@ -142,7 +144,7 @@ FC_REFLECT_DERIVED( graphene::chain::dynamic_global_property_object, (graphene::
                     (recent_slots_filled)
                     (dynamic_flags)
                     (last_irreversible_block_num)
-                    (last_scheduling_block_num)
+                    (current_scheduling_block_num)
                   )
 
 FC_REFLECT_DERIVED( graphene::chain::global_property_object, (graphene::db::object),
@@ -152,4 +154,5 @@ FC_REFLECT_DERIVED( graphene::chain::global_property_object, (graphene::db::obje
                     (active_committee_members)
                     (active_witnesses)
                     (current_activenodes)
+                    (previous_maintenance_block_num)
                   )
diff --git a/libraries/plugins/activenode/activenode.cpp b/libraries/plugins/activenode/activenode.cpp
index 87da5220..78a769d3 100644
--- a/libraries/plugins/activenode/activenode.cpp
+++ b/libraries/plugins/activenode/activenode.cpp
@@ -104,15 +104,17 @@ void activenode_plugin::plugin_initialize(const boost::program_options::variable
 void activenode_plugin::plugin_startup()
 { try {
    ilog("activenode plugin:  plugin_startup() begin");
-   chain::database& db = database();
-   const auto& account_idx = db.get_index_type<account_index>().indices().get<by_name>();
-   const auto anode_account_itr = account_idx.find(_activenode_account_name);
-   if (anode_account_itr != account_idx.end()) {
-      _activenode_account_id = anode_account_itr->id;
-      db.new_block_applied.connect( [&]( const signed_block& b){ on_new_block_applied(b); } );
-   }
-   else {
-      elog("activenode plugin: invalid activenode-account provided - no activenode associated with account with name ${activenode_account}", ("activenode_account", _activenode_account_name));
+   if (_activenode_account_name.size()) {
+      chain::database& db = database();
+      const auto& account_idx = db.get_index_type<account_index>().indices().get<by_name>();
+      const auto anode_account_itr = account_idx.find(_activenode_account_name);
+      if (anode_account_itr != account_idx.end()) {
+         _activenode_account_id = anode_account_itr->id;
+         db.new_block_applied.connect( [&]( const signed_block& b){ on_new_block_applied(b); } );
+      }
+      else {
+         elog("activenode plugin: invalid activenode-account provided - no activenode associated with account with name ${activenode_account}", ("activenode_account", _activenode_account_name));
+      }
    }
    ilog("activenode plugin:  plugin_startup() end");
 } FC_CAPTURE_AND_RETHROW() }
@@ -155,7 +157,9 @@ void activenode_plugin::on_new_block_applied(const signed_block& new_block)
 
    if (_activenode != scheduled_activenode)
       return;
-
+   if ((*_activenode)(db).last_activity == fc::time_point::now())
+      //double block appied
+      return;
    try
    {
       result = send_activity(capture);
